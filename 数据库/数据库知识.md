# 数据库知识

## 乐观锁与悲观锁	

乐观锁和悲观锁都是解决在并发场景下的数据竞争问题，可以说是两种对立的思想

乐观锁：指的是在操作数据的时候非常乐观，乐观地认为别人不会同时修改数据，因此乐观锁默认是不会上锁的，只有在执行更新的时候才会去判断在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作。

在并发量小，数据冲突情况少的情况下，由于乐观锁不上锁的特性，使用乐观锁效率和性能方面比悲观锁好。

悲观锁：指的是在操作数据的时候比较悲观，悲观地认为别人一定会同时修改数据，因此悲观锁在操作数据时是直接把数据上锁，直到操作完成之后才会释放锁，在上锁期间其他人不能操作数据。

如果在DB读取需要比较大的情况下有线程在执行数据修改操作会导致读操作全部被挂载起来，等修改线程释放了锁才能读到数据，体验极差。

总之，读取数据更多使用乐观锁，写入数据更多使用悲观锁。

### 乐观锁的实现方式:CAS机制和版本号控制

CAS机制就是　如果内存位置V的值等于预期值A，则将该位置更新为新值B；CAS操作很多是自旋的，不成功则重复。

#### CAS的缺点:ABA问题、开销成本

ABA问题：经过多次修改又回到了原来的数据。引入版本号，这也不光比较值还比较版本号，都没有变化才操作成功。

对于多个变量很难保证其操作的原子性

版本号机制就是　将数据附加一个版本号，并且在每次修改的时候版本号随之修改，读取的时候再将版本号和当前版本号比较，一致则修改，不一致则放弃。

### 悲观锁的实现方式

加锁，可以从代码层面也可以从数据库层面，如mysql的排他锁。

## 事务

### 事务的四种性质

1.原子性 即事务是最小的执行单位，不能再分割。在数据操作的过程中，要么全部执行，要么全不执行。

2.一致性 即从一个状态到另一个状态的转变，但是数据总量保持一致，不应该出现数据丢失的情况。可理解为“能量守恒”.

3.隔离性 即事务与事务之间是隔离开的，一个事务的操作执行不会影响另一个事务的执行。

4.持续性 即一个事务一旦成功提交执行，那在数据库中的数据改变时持续的，不是短暂的。

### 事务之间的相互影响

1.脏读 即两个事务同时访问一个字段，其中一个事务对字段进行了修改，但另一个事务是在修改前就已经访问了数据，那这时候就读到的是脏数据。

2.丢失更新 第一类丢失更新就是因为在撤回事务的时候，同时也把其他已提交的正常事务撤销了，这是因为没有将事务隔离开造成；第二类丢失更新是在多个事务并行时，同时对一个字段进行修改，最后一个事务对记录的操作将会覆盖掉先前其余事务的操作，因为它并不知道其他事务的存在。

3.不可重复读 同一个事务读取同一笔数据，前后结果不同。不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这回导致锁竞争加剧，影响性能。

4.幻读 同一次查询多次返回的结果不一样，是由于并发事务增加记录导致的，需要将事务串行化，才能避免幻读。

### 事务的隔离级别

1.读未提交 允许一个事务读取数据同时另外一个事务修改数据

2.读已提交 允许事务同时读数据；必须一个事务读取完数据后，另外一个事务才能修改该数据；必须等更新数据的事务执行完成后，才能对执行其他的读取或者修改该数据的事务

3.可重复读 允许事务同时读数据；必须等读取数据的事务执行完成后，才能对执行其他的修改该数据的事务；必须等更新数据的事务执行完成后，才能对执行其他的读取或者修改该数据的事务

4.可序列化 所有的事务必须等上一个事务执行完成后才开始执行